---
title: "Przewodnik po kontroli dostƒôpu opartej na rolach (RBAC)"
description: "Kompleksowy przewodnik po systemie kontroli dostƒôpu opartej na rolach w ATP System"
category: "Development"
version: "1.0.0"
lastUpdated: "2025-05-28"
createdAt: "2025-01-27"
author: "Zesp√≥≈Ç ATP System"
status: "published"
difficulty: "advanced"
readingTime: 45
docType: "guide"
requiredRole: ["admin", "developer"]
icon: "i-heroicons-user-group"
tags: ["rbac", "uprawnienia", "role", "autoryzacja", "bezpiecze≈Ñstwo"]
navigation:
  order: 115
  group: "Bezpiecze≈Ñstwo"
  title: "Przewodnik RBAC"
  description: "Implementacja kontroli dostƒôpu opartej na rolach"
related:
  - "/docs/development/security-guide"
  - "/docs/development/user-management-api"
  - "/docs/admin/user-management-guide"
  - "/docs/development/uwierzytelnianie-jwt"
seo:
  title: "Przewodnik RBAC - Kontrola dostƒôpu oparta na rolach w ATP System"
  description: "Kompletny przewodnik po implementacji i zarzƒÖdzaniu kontrolƒÖ dostƒôpu opartƒÖ na rolach (RBAC) w ATP System z uprawnieniami, rolami i bezpiecze≈Ñstwem"
  keywords: ["RBAC", "role", "uprawnienia", "kontrola dostƒôpu", "autoryzacja", "ATP System"]
---

# Przewodnik po kontroli dostƒôpu opartej na rolach (RBAC)

Kompleksowy przewodnik po implementacji i zarzƒÖdzaniu kontrolƒÖ dostƒôpu opartƒÖ na rolach w ATP System.

## üéØ PrzeglƒÖd

ATP System wykorzystuje hierarchiczny system kontroli dostƒôpu oparty na rolach (RBAC), kt√≥ry zapewnia bezpieczne, skalowalne i elastyczne zarzƒÖdzanie uprawnieniami we wszystkich komponentach systemu. System obs≈Çuguje **przypisania wielu r√≥l**, gdzie u≈ºytkownicy mogƒÖ mieƒá wiele r√≥l jednocze≈õnie, z uprawnieniami agregowanymi ze wszystkich przypisanych r√≥l.

---

## üèóÔ∏è Architektura RBAC

### Hierarchia systemu
```mermaid
graph TD
    A[ADMIN] --> B[MANAGER]
    A --> C[COACH]
    A --> D[ATHLETE]
    A --> E[USER]
    A --> F[OBSERVER]
    A --> G[EDITOR]
    B --> C
    B --> D
    B --> E
    B --> F
    C --> D
    C --> E
    C --> F
    E --> F
    G --> E
    G --> F
    D --> E
    D --> F
```

### Core Components

#### 1. Role System (UserRoleEnum)
```typescript
export enum UserRoleEnum {
  /**
   * Administrator systemu - pe≈Çen dostƒôp do wszystkich funkcji
   */
  ADMIN = 'admin',
  
  /**
   * Trener - mo≈ºe zarzƒÖdzaƒá programami treningowymi i podopiecznymi
   */
  COACH = 'coach',
  
  /**
   * Sportowiec - mo≈ºe przeglƒÖdaƒá swoje programy treningowe i wyniki
   */
  ATHLETE = 'athlete',
  
  /**
   * Manager - zarzƒÖdza aspektami organizacyjnymi, ale nie treningowymi
   */
  MANAGER = 'manager',
  
  /**
   * Editor - osoba mogƒÖca dodawaƒá i zarzƒÖdzaƒá tre≈õciami w systemie CMS
   */
  EDITOR = 'editor',
  
  /**
   * U≈ºytkownik - osoba posiadajƒÖca konto w systemie z podstawowymi uprawnieniami
   */
  USER = 'user',
  
  /**
   * Obserwator - osoba mogƒÖca jedynie przeglƒÖdaƒá publicznie dostƒôpne tre≈õci
   */
  OBSERVER = 'observer',
}
```

#### 2. System uprawnie≈Ñ (format resource:action)
```typescript
export const PERMISSIONS = {
  // ===== ZARZƒÑDZANIE U≈ªYTKOWNIKAMI =====
  USER_VIEW: 'user:view',
  USER_CREATE: 'user:create',
  USER_EDIT: 'user:edit',
  USER_DELETE: 'user:delete',
  USER_ASSIGN_ROLE: 'user:assign_role',
  PROFILE_VIEW: 'profile:view',

  // ===== PROGRAMY TRENINGOWE =====
  TRAINING_VIEW: 'training:view',
  TRAINING_VIEW_ALL: 'training:view:all',
  TRAINING_CREATE: 'training:create',
  TRAINING_EDIT: 'training:edit',
  TRAINING_DELETE: 'training:delete',
  TRAINING_ASSIGN: 'training:assign',
  TRAINING_ENROLL: 'training:enroll',

  // ===== WYNIKI I POSTƒòPY =====
  PROGRESS_VIEW: 'progress:view',
  PROGRESS_VIEW_ALL: 'progress:view:all',
  PROGRESS_ADD: 'progress:add',
  PROGRESS_EDIT: 'progress:edit',
  PROGRESS_DELETE: 'progress:delete',

  // ===== ZARZƒÑDZANIE TRE≈öCIƒÑ =====
  CONTENT_VIEW: 'content:view',
  CONTENT_VIEW_PUBLIC: 'content:view:public',
  CONTENT_CREATE: 'content:create',
  CONTENT_EDIT: 'content:edit',
  CONTENT_DELETE: 'content:delete',
  CONTENT_PUBLISH: 'content:publish',
  
  // ... i inne uprawnienia
} as const;
```

#### 3. Hierarchia r√≥l z wielodziedziczeniem
```typescript
export const ROLE_HIERARCHY: Record<RoleSlug, RoleSlugs> = {
  [USER_ROLES.ADMIN]: [
    USER_ROLES.MANAGER, 
    USER_ROLES.COACH, 
    USER_ROLES.ATHLETE, 
    USER_ROLES.USER, 
    USER_ROLES.OBSERVER, 
    USER_ROLES.EDITOR
  ],
  [USER_ROLES.MANAGER]: [
    USER_ROLES.COACH, 
    USER_ROLES.ATHLETE, 
    USER_ROLES.USER, 
    USER_ROLES.OBSERVER
  ],
  [USER_ROLES.COACH]: [
    USER_ROLES.ATHLETE, 
    USER_ROLES.USER, 
    USER_ROLES.OBSERVER
  ],
  [USER_ROLES.EDITOR]: [
    USER_ROLES.USER, 
    USER_ROLES.OBSERVER
  ],
  [USER_ROLES.ATHLETE]: [
    USER_ROLES.USER, 
    USER_ROLES.OBSERVER
  ],
  [USER_ROLES.USER]: [
    USER_ROLES.OBSERVER
  ],
  [USER_ROLES.OBSERVER]: []
};
```

---

## üé≠ Definicje r√≥l

### ADMIN
**Najwy≈ºszy poziom uprawnie≈Ñ** - Pe≈Çna kontrola systemu

**Opis:** Administrator systemu z dostƒôpem do wszystkich funkcji

**Uprawnienia:**
- **Wszystkie uprawnienia w systemie** (Object.values(PERMISSIONS))
- ZarzƒÖdzanie u≈ºytkownikami i rolami
- Konfiguracja systemu
- ZarzƒÖdzanie bezpiecze≈Ñstwem
- Dostƒôp do bazy danych

**Przypadki u≈ºycia:**
- Konserwacja systemu
- ZarzƒÖdzanie w sytuacjach awaryjnych
- Incydenty bezpiecze≈Ñstwa
- PoczƒÖtkowa konfiguracja systemu

**Implementacja:**
```typescript
// Administrator ma wszystkie uprawnienia
[USER_ROLES.ADMIN]: Object.values(PERMISSIONS) as Permissions
```

### MANAGER
**ZarzƒÖdzanie organizacyjne** - Nadz√≥r nad zespo≈Çami

**Opis:** ZarzƒÖdza aspektami organizacyjnymi, trenerami i sportowcami

**Uprawnienia:**
```typescript
const managerPermissions = [
  // ZarzƒÖdzanie u≈ºytkownikami
  'user:view', 'user:create', 'user:edit',
  
  // Programy treningowe
  'training:view', 'training:view:all',
  'training:create', 'training:edit',
  
  // Wyniki i postƒôpy
  'progress:view:all', 'progress:edit',
  
  // Tre≈õci
  'content:view', 'content:create', 'content:edit',
  
  // Harmonogram
  'schedule:view:all', 'schedule:create',
  'schedule:edit', 'schedule:delete',
  
  // Komunikacja
  'message:send', 'message:view', 'notification:send',
  
  // Statystyki i raporty
  'stats:view', 'stats:advanced', 'report:generate'
]
```

**Dziedziczenie:**
- Wszystkie uprawnienia COACH, ATHLETE, USER, OBSERVER

### COACH
**ZarzƒÖdzanie treningami** - Trener sportowy

**Opis:** Mo≈ºe zarzƒÖdzaƒá programami treningowymi i podopiecznymi

**Uprawnienia:**
```typescript
const coachPermissions = [
  // ZarzƒÖdzanie u≈ºytkownikami
  'user:view',
  
  // Programy treningowe
  'training:view', 'training:view:all',
  'training:create', 'training:edit', 'training:assign',
  
  // Wyniki i postƒôpy
  'progress:view:all', 'progress:add', 'progress:edit',
  
  // Harmonogram
  'schedule:view', 'schedule:view:all',
  'schedule:create', 'schedule:edit',
  
  // Komunikacja
  'message:send', 'message:view', 'notification:send',
  
  // Statystyki
  'stats:view', 'report:generate'
]
```

**Ograniczenia zakresu:**
- Mo≈ºe zarzƒÖdzaƒá tylko przypisanymi sportowcami
- Nie mo≈ºe usuwaƒá u≈ºytkownik√≥w
- Nie ma dostƒôpu do konfiguracji systemu

### ATHLETE
**Sportowiec** - Uczestnik program√≥w treningowych

**Opis:** Mo≈ºe przeglƒÖdaƒá swoje programy treningowe i wyniki

**Uprawnienia:**
```typescript
const athletePermissions = [
  // Programy treningowe
  'training:view',
  
  // Wyniki i postƒôpy
  'progress:view', 'progress:add',
  
  // Tre≈õci
  'content:view',
  
  // Harmonogram
  'schedule:view',
  
  // Komunikacja
  'message:send', 'message:view',
  
  // Statystyki
  'stats:view'
]
```

**Charakterystyka:**
- Dostƒôp tylko do w≈Çasnych danych treningowych
- Mo≈ºe dodawaƒá swoje wyniki
- Ograniczony dostƒôp do komunikacji

### EDITOR
**Redaktor tre≈õci** - ZarzƒÖdzanie contentem

**Opis:** Osoba mogƒÖca dodawaƒá i zarzƒÖdzaƒá tre≈õciami w systemie CMS

**Uprawnienia:**
```typescript
const editorPermissions = [
  // Tre≈õci
  'content:view', 'content:create',
  'content:edit', 'content:delete', 'content:publish',
  
  // Harmonogram
  'schedule:view',
  
  // Komunikacja
  'message:send', 'message:view',
  
  // Podstawowe
  'stats:view'
]
```

**Specjalizacja:**
- Fokus na zarzƒÖdzaniu tre≈õciƒÖ
- Uprawnienia publikacyjne
- Brak dostƒôpu do danych treningowych

### USER
**Zwyk≈Çy u≈ºytkownik** - Podstawowe funkcje

**Opis:** Osoba posiadajƒÖca konto w systemie z podstawowymi uprawnieniami

**Uprawnienia:**
```typescript
const userPermissions = [
  // Tre≈õci
  'content:view',
  
  // Harmonogram
  'schedule:view',
  
  // Komunikacja
  'message:send', 'message:view'
]
```

**Charakterystyka:**
- Podstawowe interakcje z systemem
- Ograniczony dostƒôp do funkcji premium
- Wymaga logowania

### OBSERVER
**Obserwator** - Tylko przeglƒÖdanie

**Opis:** Osoba mogƒÖca jedynie przeglƒÖdaƒá publicznie dostƒôpne tre≈õci

**Uprawnienia:**
```typescript
const observerPermissions = [
  'content:view',
  'profile:view',
  'content:view:public',
  'material:view',
  'notification:view',
  'notification:manage', // tylko w≈Çasne
  'progress:update',      // tylko w≈Çasne postƒôpy
  'statistics:view',      // tylko w≈Çasne statystyki
  'settings:view',
  'settings:edit',        // tylko w≈Çasne ustawienia
  'settings:notifications',
  'search',
  'faq:view',
  'docs:view',
  'calendar:view',
]
```

**Charakterystyka:**
- Najni≈ºszy poziom uprawnie≈Ñ
- G≈Ç√≥wnie funkcje przeglƒÖdania
- Brak mo≈ºliwo≈õci interakcji z systemem

## üõ°Ô∏è Multi-Role Permission System

### Permission Checking Logic

ATP System wykorzystuje zaawansowany system sprawdzania uprawnie≈Ñ obs≈ÇugujƒÖcy **wiele r√≥l jednocze≈õnie**:

#### Core Permission Functions
```typescript
/**
 * Sprawdza, czy u≈ºytkownik z podanymi rolami ma konkretne uprawnienie
 */
export function hasPermissionMultiRole(userRoles: RoleSlugs, permission: Permission): boolean {
  // Administrator ma wszystkie uprawnienia
  if (userRoles.includes(USER_ROLES.ADMIN)) return true;

  // Sprawd≈∫ we wszystkich rolach u≈ºytkownika
  for (const role of userRoles) {
    if (hasPermission(role, permission)) return true;
  }

  return false;
}

/**
 * Sprawdza wszystkie uprawnienia dla wielu r√≥l
 */
export function hasAllPermissionsMultiRole(userRoles: RoleSlugs, permissions: Permissions): boolean {
  return permissions.every(permission => hasPermissionMultiRole(userRoles, permission));
}

/**
 * Sprawdza czy u≈ºytkownik ma kt√≥rekolwiek z podanych uprawnie≈Ñ
 */
export function hasAnyPermissionMultiRole(userRoles: RoleSlugs, permissions: Permissions): boolean {
  return permissions.some(permission => hasPermissionMultiRole(userRoles, permission));
}
```

#### Permission with Role Hierarchy
```typescript
export function hasPermission(userRole: RoleSlug, permission: Permission): boolean {
  // Administrator ma wszystkie uprawnienia
  if (userRole === USER_ROLES.ADMIN) return true;
  
  // Sprawd≈∫ bezpo≈õrednie uprawnienia roli
  if (ROLE_PERMISSIONS[userRole]?.includes(permission)) return true;
  
  // Sprawd≈∫ uprawnienia dziedziczone z hierarchii r√≥l
  const inheritedRoles = ROLE_HIERARCHY[userRole] || [];
  for (const inheritedRole of inheritedRoles) {
    if (ROLE_PERMISSIONS[inheritedRole]?.includes(permission)) return true;
  }
  
  return false;
}
```

### Backend Implementation

#### Server Middleware - Permission Checking
```typescript
// server/middleware/check-permission.ts
export default defineEventHandler(async (event) => {
  // Sprawdzenie czy endpoint wymaga uprawnie≈Ñ
  const requiredPermission = getRequiredPermission(event.node.req.url);
  if (!requiredPermission) return;

  // Pobranie sesji u≈ºytkownika
  const session = await getUserSession(event);
  if (!session?.user?.id) {
    throw createError({
      statusCode: 401,
      message: 'Authentication required'
    });
  }

  // Pobranie r√≥l u≈ºytkownika
  const userRoles = await getUserRoles(session.user.id);
  
  // Sprawdzenie uprawnie≈Ñ z obs≈ÇugƒÖ wielu r√≥l
  const hasRequiredPermission = await checkPermissionByRoles(
    session.user.id,
    userRoles,
    requiredPermission
  );

  if (!hasRequiredPermission) {
    throw createError({
      statusCode: 403,
      message: 'Insufficient permissions'
    });
  }
});
```

#### API Permissions Mapping
```typescript
// server/utils/api-permissions-map.ts
export const API_PERMISSION_MAP: Record<string, Permission> = {
  // U≈ºytkownicy
  '/api/users': PERMISSIONS.USER_VIEW,
  '/api/users/create': PERMISSIONS.USER_CREATE,
  '/api/users/\\d+/edit': PERMISSIONS.USER_EDIT,
  '/api/users/\\d+/delete': PERMISSIONS.USER_DELETE,
  
  // Treningi
  '/api/trainings': PERMISSIONS.TRAINING_VIEW,
  '/api/trainings/create': PERMISSIONS.TRAINING_CREATE,
  '/api/trainings/\\d+/edit': PERMISSIONS.TRAINING_EDIT,
  
  // Tre≈õci
  '/api/content': PERMISSIONS.CONTENT_VIEW,
  '/api/content/create': PERMISSIONS.CONTENT_CREATE,
  '/api/content/\\d+/edit': PERMISSIONS.CONTENT_EDIT,
  '/api/content/\\d+/publish': PERMISSIONS.CONTENT_PUBLISH,
  
  // Postƒôpy
  '/api/progress': PERMISSIONS.PROGRESS_VIEW,
  '/api/progress/\\d+/update': PERMISSIONS.PROGRESS_UPDATE,
  
  // Ustawienia
  '/api/settings': PERMISSIONS.SETTINGS_VIEW,
  '/api/settings/updated': PERMISSIONS.SETTINGS_EDIT,
};
```

### Implementacja Frontend

#### Composable usePermissions
```typescript
// app/composables/usePermissions.ts
export function usePermissions() {
  const { session: authSession } = useAuth();

  // Pobierz role u≈ºytkownika
  const userRoles = computed(() => {
    if (authSession.value?.roles && Array.isArray(authSession.value.roles)) {
      return authSession.value.roles;
    }
    return [USER_ROLES.OBSERVER]; // Domy≈õlnie
  });

  // Sprawd≈∫ pojedyncze uprawnienie
  const can = (permission: Permission) => {
    return hasPermissionMultiRole(userRoles.value, permission);
  };

  // Sprawd≈∫ wszystkie uprawnienia
  const canAll = (permissions: Permission[]) => {
    return hasAllPermissionsMultiRole(userRoles.value, permissions);
  };

  // Sprawd≈∫ kt√≥rekolwiek uprawnienie
  const canAny = (permissions: Permission[]) => {
    return hasAnyPermissionMultiRole(userRoles.value, permissions);
  };

  return { userRoles, can, canAll, canAny };
}
```

#### Vue Permission Directive
```typescript
// app/plugins/permission.directive.ts
export default defineNuxtPlugin((nuxtApp) => {
  nuxtApp.vueApp.directive('permission', {
    mounted(el: HTMLElement, binding) {
      const { can } = usePermissions();
      const permission = binding.value;
      
      if (!can(permission)) {
        el.style.display = 'none';
      }
    },
    updated(el: HTMLElement, binding) {
      const { can } = usePermissions();
      const permission = binding.value;
      
      el.style.display = can(permission) ? '' : 'none';
    }
  });
});
```

#### Template Usage Examples
```vue
<template>
  <div>
    <!-- Dyrektywa v-permission -->
    <button v-permission="'user:create'">
      Dodaj u≈ºytkownika
    </button>
    
    <!-- Composable w template -->
    <div v-if="can('training:create')">
      <TrainingForm />
    </div>
    
    <!-- Sprawdzanie wielu uprawnie≈Ñ -->
    <AdminPanel v-if="canAny(['user:create', 'user:edit', 'user:delete'])" />
    
    <!-- Warunki dla r√≥l -->
    <CoachDashboard v-if="userRoles.includes('coach')" />
    <AthleteProfile v-if="userRoles.includes('athlete')" />
  </div>
</template>

<script setup>
const { can, canAny, userRoles } = usePermissions();
</script>
```

---
  
  UNIQUE(role, permission, scope)
);
```

#### User Teams Table (for scope management)
```sql
CREATE TABLE user_teams (
  id SERIAL PRIMARY KEY,
  user_id INTEGER REFERENCES users(id),
  team_id INTEGER REFERENCES teams(id),
  role VARCHAR(50),
  assigned_by INTEGER REFERENCES users(id),
  assigned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### Permission Service

#### Core Service Implementation
```typescript
class PermissionService {
  private rolePermissions: Map<UserRole, Permission[]> = new Map()
  
  constructor() {
    this.initializeRolePermissions()
  }
  
  private initializeRolePermissions() {
    // Initialize role-permission mappings
    this.rolePermissions.set(UserRole.SUPER_ADMIN, getAllPermissions())
    this.rolePermissions.set(UserRole.ADMIN, adminPermissions)
    this.rolePermissions.set(UserRole.MANAGER, managerPermissions)
    this.rolePermissions.set(UserRole.COACH, coachPermissions)
    this.rolePermissions.set(UserRole.EDITOR, editorPermissions)
    this.rolePermissions.set(UserRole.ATHLETE, athletePermissions)
    this.rolePermissions.set(UserRole.PUBLIC, publicPermissions)
  }
  
  async checkPermission(
    userId: number, 
    permission: Permission, 
    resourceId?: number
  ): Promise<boolean> {
    const user = await this.getUserWithRole(userId)
    const rolePermissions = this.rolePermissions.get(user.role) || []
    
    // Check if user has base permission
    if (!rolePermissions.includes(permission)) {
      return false
    }
    
    // Check scope-based permissions
    return await this.checkScopePermission(user, permission, resourceId)
  }
  
  private async checkScopePermission(
    user: User, 
    permission: Permission, 
    resourceId?: number
  ): Promise<boolean> {
    // Implement scope-based permission checking
    switch (user.role) {
      case UserRole.COACH:
        return await this.checkCoachScope(user.id, permission, resourceId)
      case UserRole.ATHLETE:
        return await this.checkAthleteScope(user.id, permission, resourceId)
      default:
        return true // Admin and above have full scope
    }
  }
  
  async getUserPermissions(userId: number): Promise<Permission[]> {
    const user = await this.getUserWithRole(userId)
    return this.rolePermissions.get(user.role) || []
  }
}
```

### Frontend Composable

#### usePermissions Composable
```typescript
// composables/usePermissions.ts
export function usePermissions() {
  const { user } = useAuth()
  
  const hasPermission = (permission: Permission): boolean => {
    ## üóÑÔ∏è Schemat bazy danych

### Rzeczywiste modele bazy danych ATP System

ATP System wykorzystuje SQLite z Drizzle ORM dla zarzƒÖdzania bazƒÖ danych z systemem r√≥l opartym na relacji many-to-many.

#### Tabela u≈ºytkownik√≥w
```typescript
// server/database/models/users.model.ts
export const users = sqliteTable('users', {
    id: integer('id').primaryKey({ autoIncrement: true }),
    username: text('username').notNull(),
    email: text('email').notNull().unique(),
    password: text('password').notNull(),
    avatarUrl: text('avatar_url'),
    firstName: text('first_name'),
    lastName: text('last_name'),
    bio: text('bio'),
    status: text('status').default(USER_STATUSES.ACTIVE).$type<UserStatus>(),
    isAgreedToTerms: integer('is_agreed_to_terms').notNull().default(0),
    isOAuthAccount: integer('is_oauth_account', { mode: 'boolean' }).default(false),
    createdAt: integer('created_at', { mode: 'timestamp' }).notNull(),
    updatedAt: integer('updated_at', { mode: 'timestamp' }),
});
```

#### Tabela r√≥l
```typescript
// server/database/models/roles.model.ts
export const roles = sqliteTable('roles', {
    id: integer('id').primaryKey({ autoIncrement: true }),
    name: text('name').notNull().unique(),
    slug: text('slug').notNull().unique(), // np. "admin", "coach", "athlete"
    description: text('description'),
    isSystem: integer('is_system', { mode: 'boolean' }).default(false), // Role systemowe
    createdAt: integer('created_at', { mode: 'timestamp' }).notNull(),
    updatedAt: integer('updated_at', { mode: 'timestamp' }),
});
```

#### Tabela po≈ÇƒÖcze≈Ñ r√≥l u≈ºytkownik√≥w (Many-to-Many)
```typescript
// server/database/models/user_roles.model.ts
export const userRoles = sqliteTable('user_roles', {
    userId: integer('user_id').notNull().references(() => users.id),
    roleId: integer('role_id').notNull().references(() => roles.id),
    assignedAt: integer('assigned_at', { mode: 'timestamp' }).notNull(),
    assignedBy: integer('assigned_by').references(() => users.id),
});
```

#### Drizzle Relations Configuration
```typescript
// server/database/schema.ts
export const userRolesRelations = relations(userRoles, ({ one }) => ({
    user: one(users, {
        fields: [userRoles.userId],
        references: [users.id],
        relationName: 'userRoles'
    }),
    role: one(roles, {
        fields: [userRoles.roleId],
        references: [roles.id]
    }),
    assignedByUser: one(users, {
        fields: [userRoles.assignedBy],
        references: [users.id],
        relationName: 'assignedRoles'
    })
}));

export const usersRelations = relations(users, ({ many }) => ({
    roles: many(userRoles, {
        relationName: 'userRoles'
    }),
    assignedRoles: many(userRoles, {
        relationName: 'assignedRoles'
    }),
    refreshTokens: many(refreshTokens)
}));
```

### Role Management Repository

#### User Roles Repository
```typescript
// server/utils/repositories/user_roles.repositories.ts
export async function getUserRoles(userId: number): Promise<RoleSlug[]> {
  const userWithRoles = await db
    .select({
      roleSlug: roles.slug
    })
    .from(userRoles)
    .innerJoin(roles, eq(userRoles.roleId, roles.id))
    .where(eq(userRoles.userId, userId));

  return userWithRoles.map(row => row.roleSlug as RoleSlug);
}

export async function assignRoleToUser(
  userId: number, 
  roleSlug: RoleSlug, 
  assignedBy: number
): Promise<void> {
  // Znajd≈∫ rolƒô po slug
  const [role] = await db
    .select({ id: roles.id })
    .from(roles)
    .where(eq(roles.slug, roleSlug));

  if (!role) {
    throw new Error(`Role '${roleSlug}' not found`);
  }

  // Sprawd≈∫ czy u≈ºytkownik ju≈º ma tƒô rolƒô
  const existingAssignment = await db
    .select()
    .from(userRoles)
    .where(
      and(
        eq(userRoles.userId, userId),
        eq(userRoles.roleId, role.id)
      )
    );

  if (existingAssignment.length > 0) {
    throw new Error('User already has this role');
  }

  // Przypisz rolƒô
  await db.insert(userRoles).values({
    userId,
    roleId: role.id,
    assignedAt: new Date(),
    assignedBy
  });
}

export async function removeRoleFromUser(
  userId: number, 
  roleSlug: RoleSlug
): Promise<void> {
  // Znajd≈∫ rolƒô po slug
  const [role] = await db
    .select({ id: roles.id })
    .from(roles)
    .where(eq(roles.slug, roleSlug));

  if (!role) {
    throw new Error(`Role '${roleSlug}' not found`);
  }

  // Usu≈Ñ przypisanie roli
  await db
    .delete(userRoles)
    .where(
      and(
        eq(userRoles.userId, userId),
        eq(userRoles.roleId, role.id)
      )
    );
}
```

---
      
    ## üöÄ Praktyczne Przyk≈Çady U≈ºycia

### 1. Middleware uwierzytelniania na stronach

```typescript
// app/middleware/auth.ts
export default defineNuxtRouteMiddleware((to) => {
    const { session } = useAuth();
    const { can } = usePermissions();

    // Sprawd≈∫ czy strona wymaga logowania
    if (!session.value?.user) {
        return navigateTo('/auth/login');
    }    // Sprawd≈∫ uprawnienia na podstawie tras
    const routePermissions = getRoutePermissions(to.path);
    if (routePermissions && !can(routePermissions)) {
        throw createError({
            statusCode: 403,
            statusMessage: 'NiewystarczajƒÖce uprawnienia'
        });
    }

    // Specjalne sprawdzenia dla sekcji administracyjnej
    if (to.path.startsWith('/dashboard/admin') && 
        !session.value?.roles?.includes(USER_ROLES.ADMIN)) {
        return navigateTo('/auth/403');
    }
});

function getRoutePermissions(path: string): Permission | null {
    const routePermissionMap: Record<string, Permission> = {
        '/dashboard/users': PERMISSIONS.USER_VIEW,
        '/dashboard/users/create': PERMISSIONS.USER_CREATE,
        '/dashboard/training': PERMISSIONS.TRAINING_VIEW,
        '/dashboard/content': PERMISSIONS.CONTENT_VIEW,
    };
    
    return routePermissionMap[path] || null;
}
```

### 2. Warunkowe wy≈õwietlanie komponent√≥w

```vue
<!-- app/pages/dashboard/users/index.vue -->
<template>
  <div>
    <h1>ZarzƒÖdzanie u≈ºytkownikami</h1>
    
    <!-- Przycisk tylko dla administrator√≥w -->
    <UButton 
      v-if="can('user:create')"
      @click="createUser"
      icon="i-heroicons-plus"
    >
      Dodaj u≈ºytkownika
    </UButton>
    
    <!-- Lista u≈ºytkownik√≥w -->
    <UTable :rows="users" :columns="columns">
      <template #actions-data="{ row }">
        <!-- Edycja tylko z uprawnieniem -->
        <UButton 
          v-if="can('user:edit')"
          size="sm" 
          @click="editUser(row.id)"
        >
          Edytuj
        </UButton>
        
        <!-- Usuwanie tylko dla administrator√≥w -->
        <UButton 
          v-if="userRoles.includes('admin')"
          size="sm" 
          color="red"
          @click="deleteUser(row.id)"
        >
          Usu≈Ñ
        </UButton>
      </template>
    </UTable>
  </div>
</template>

<script setup>
definePageMeta({
  middleware: ['auth'],
  layout: 'dashboard'
});

const { can, userRoles } = usePermissions();

// Sprawd≈∫ uprawnienia na poziomie strony
if (!can('user:view')) {
  throw createError({
    statusCode: 403,
    statusMessage: 'Brak uprawnie≈Ñ do przeglƒÖdania u≈ºytkownik√≥w'
  });
}

const users = await $fetch('/api/users');
</script>
```

### 3. API Routes z kontrolƒÖ uprawnie≈Ñ

```typescript
// server/api/users/index.get.ts
export default defineEventHandler(async (event) => {
  // Middleware automatycznie sprawdza uprawnienia dla '/api/users'
  // Na podstawie API_PERMISSION_MAP: PERMISSIONS.USER_VIEW
  
  const { session } = await requireUserSession(event);
  const userRoles = await getUserRoles(session.user.id);
  
  // Administratorzy widzƒÖ wszystkich u≈ºytkownik√≥w
  if (userRoles.includes(USER_ROLES.ADMIN)) {
    return await getAllUsers();
  }
  
  // Trenerzy widzƒÖ tylko swoich sportowc√≥w
  if (userRoles.includes(USER_ROLES.COACH)) {
    return await getCoachAthletes(session.user.id);
  }
  
  // Pozostali widzƒÖ tylko siebie
  return await getUserProfile(session.user.id);
});
```

### 4. Dynamiczne menu na podstawie r√≥l

```vue
<!-- app/components/Navigation/Sidebar.vue -->
<template>
  <nav class="sidebar">
    <ul>
      <!-- Menu dla wszystkich zalogowanych -->
      <li>
        <NuxtLink to="/dashboard">Dashboard</NuxtLink>
      </li>
      
      <!-- Menu administratorskie -->
      <li v-if="canAny(['user:view', 'user:create', 'user:edit'])">
        <details>
          <summary>U≈ºytkownicy</summary>
          <ul>
            <li v-if="can('user:view')">
              <NuxtLink to="/dashboard/users">Lista u≈ºytkownik√≥w</NuxtLink>
            </li>
            <li v-if="can('user:create')">
              <NuxtLink to="/dashboard/users/create">Dodaj u≈ºytkownika</NuxtLink>
            </li>
          </ul>
        </details>
      </li>
      
      <!-- Menu treningowe -->
      <li v-if="canAny(['training:view', 'training:create'])">
        <details>
          <summary>Treningi</summary>
          <ul>
            <li v-if="can('training:view')">
              <NuxtLink to="/dashboard/training">Moje treningi</NuxtLink>
            </li>
            <li v-if="can('training:create')">
              <NuxtLink to="/dashboard/training/create">Stw√≥rz trening</NuxtLink>
            </li>
          </ul>
        </details>
      </li>
      
      <!-- Menu zarzƒÖdzania tre≈õciƒÖ -->
      <li v-if="userRoles.includes('editor')">
        <NuxtLink to="/dashboard/content">ZarzƒÖdzanie tre≈õciƒÖ</NuxtLink>
      </li>
      
      <!-- Panel administracyjny tylko dla admin√≥w -->
      <li v-if="userRoles.includes('admin')">
        <NuxtLink to="/dashboard/admin">Panel administracyjny</NuxtLink>
      </li>
    </ul>
  </nav>
</template>

<script setup>
const { can, canAny, userRoles } = usePermissions();
</script>
```

### 5. Formularz z warunkowymi polami

```vue
<!-- app/components/UserForm.vue -->
<template>
  <UForm :state="formState" @submit="onSubmit">
    <!-- Podstawowe pola dla wszystkich -->
    <UFormGroup label="Email" name="email">
      <UInput v-model="formState.email" type="email" required />
    </UFormGroup>
    
    <UFormGroup label="Imiƒô" name="firstName">
      <UInput v-model="formState.firstName" required />
    </UFormGroup>
    
    <!-- Role - tylko dla administrator√≥w -->
    <UFormGroup v-if="can('user:assign_role')" label="Role" name="roles">
      <USelectMenu 
        v-model="formState.roles"
        :options="availableRoles"
        multiple
        placeholder="Wybierz role"
      />
    </UFormGroup>
    
    <!-- Status - tylko dla mened≈ºer√≥w i administrator√≥w -->
    <UFormGroup 
      v-if="canAny(['user:edit', 'user:delete'])" 
      label="Status" 
      name="status"
    >
      <USelect 
        v-model="formState.status"
        :options="userStatuses"
      />
    </UFormGroup>
    
    <!-- Przypisanie trenera - tylko dla administrator√≥w i mened≈ºer√≥w -->
    <UFormGroup 
      v-if="canAny(['training:assign', 'user:edit']) && formState.roles?.includes('athlete')"
      label="Przypisany trener"
      name="coachId"
    >
      <USelectMenu 
        v-model="formState.coachId"
        :options="coaches"
        placeholder="Wybierz trenera"
      />
    </UFormGroup>

    <UButton type="submit" :loading="isSubmitting">
      {{ isEditing ? 'Aktualizuj' : 'Utw√≥rz' }} u≈ºytkownika
    </UButton>
  </UForm>
</template>

<script setup>
interface Props {
  user?: User;
  isEditing?: boolean;
}

const props = withDefaults(defineProps<Props>(), {
  isEditing: false
});

const { can, canAny, userRoles } = usePermissions();

// Filtruj dostƒôpne role na podstawie uprawnie≈Ñ
const availableRoles = computed(() => {
  const allRoles = Object.values(USER_ROLES);
  
  if (userRoles.value.includes(USER_ROLES.ADMIN)) {
    return allRoles; // Admin mo≈ºe przypisaƒá wszystkie role
  }
  
  if (userRoles.value.includes(USER_ROLES.MANAGER)) {
    // Manager nie mo≈ºe przypisaƒá roli admin
    return allRoles.filter(role => role !== USER_ROLES.ADMIN);
  }
  
  return []; // Pozostali nie mogƒÖ przypisywaƒá r√≥l
});

const formState = reactive({
  email: props.user?.email || '',
  firstName: props.user?.firstName || '',
  roles: props.user?.roles || [],
  status: props.user?.status || 'active',
  coachId: null
});
</script>
```

---
      if (hour < tbp.hoursOfDay.start || hour > tbp.hoursOfDay.end) {
        return false
      }
    }
    
    return true
  }
}
```

### Feature Flags
```typescript
interface FeatureFlag {
  name: string
  enabled: boolean
  roles: UserRole[]
  percentage?: number // Gradual rollout
}

class FeatureFlagService {
  async isFeatureEnabled(userId: number, featureName: string): Promise<boolean> {
    const flag = await this.getFeatureFlag(featureName)
    if (!flag || !flag.enabled) return false
    
    const user = await getUserWithRole(userId)
    
    // Check role access
    if (!flag.roles.includes(user.role)) return false
    
    // Check percentage rollout
    if (flag.percentage && flag.percentage < 100) {
      const userHash = this.hashUserId(userId)
      return userHash % 100 < flag.percentage
    }
    
    return true
  }
}
```

---

## üß™ Testowanie RBAC

### Testowanie uprawnie≈Ñ

#### Testy jednostkowe
```typescript
describe('PermissionService', () => {
  let permissionService: PermissionService
  
  beforeEach(() => {
    permissionService = new PermissionService()
  })
  
  describe('checkPermission', () => {
    it('powinien pozwoliƒá administratorowi czytaƒá dowolnego u≈ºytkownika', async () => {
      const admin = createMockUser({ role: UserRole.ADMIN })
      const result = await permissionService.checkPermission(
        admin.id, 
        Permission.USER_READ, 
        123
      )
      
      expect(result).toBe(true)
    })
    
    it('powinien uniemo≈ºliwiƒá sportowcowi czytanie danych innych u≈ºytkownik√≥w', async () => {
      const athlete = createMockUser({ role: UserRole.ATHLETE })
      const result = await permissionService.checkPermission(
        athlete.id, 
        Permission.USER_READ, 
        999 // Inne ID u≈ºytkownika
      )
      
      expect(result).toBe(false)
    })
    
    it('powinien pozwoliƒá trenerowi czytaƒá dane przypisanych sportowc√≥w', async () => {
      const coach = createMockUser({ role: UserRole.COACH })
      const athlete = createMockUser({ role: UserRole.ATHLETE })
      
      // Ustaw przypisanie
      await createCoachAthleteAssignment(coach.id, athlete.id)
      
      const result = await permissionService.checkPermission(
        coach.id, 
        Permission.USER_READ, 
        athlete.id
      )
      
      expect(result).toBe(true)
    })
  })
})
```

#### Testy integracyjne
```typescript
describe('Integracja RBAC', () => {  it('powinien wymuszaƒá uprawnienia na endpointach API', async () => {
    const athlete = await createTestUser({ role: UserRole.ATHLETE })
    const token = generateJWT(athlete)
    
    // Pr√≥ba dostƒôpu do endpointa tylko dla administrator√≥w
    const response = await request(app)
      .get('/api/admin/users')
      .set('Authorization', `Bearer ${token}`)
    
    expect(response.status).toBe(403)
    expect(response.body.message).toBe('NiewystarczajƒÖce uprawnienia')
  })
  
  it('powinien pozwoliƒá na dostƒôp odpowiedni dla roli', async () => {
    const admin = await createTestUser({ role: UserRole.ADMIN })
    const token = generateJWT(admin)
    
    const response = await request(app)
      .get('/api/admin/users')
      .set('Authorization', `Bearer ${token}`)
    
    expect(response.status).toBe(200)
    expect(response.body.status).toBe('success')
  })
})
```

---

## üìä Monitorowanie RBAC

### Audyt uprawnie≈Ñ

#### Dziennik audytu
```typescript
interface PermissionAuditLog {
  id: string
  userId: number
  permission: Permission
  resource?: string
  resourceId?: number
  action: 'granted' | 'denied' | 'requested'
  timestamp: Date
  context: {
    ip: string
    userAgent: string
    sessionId: string
    requestId: string
  }
  reason?: string
}

class PermissionAuditor {
  async logPermissionCheck(
    userId: number,
    permission: Permission,
    result: boolean,
    context: AuditContext
  ) {
    const log: PermissionAuditLog = {
      id: generateUUID(),
      userId,
      permission,
      action: result ? 'granted' : 'denied',
      timestamp: new Date(),
      context,
      reason: result ? undefined : 'NiewystarczajƒÖce uprawnienia'
    }
    
    await this.saveAuditLog(log)
    
    // Ostrze≈ºenie o podejrzanych wzorcach
    if (!result) {
      await this.checkSuspiciousActivity(userId, permission)
    }
  }
  
  private async checkSuspiciousActivity(userId: number, permission: Permission) {
    const recentDenials = await this.getRecentDenials(userId, '1 hour')
    
    if (recentDenials.length > 10) {
      await this.alertSecurityTeam({
        type: 'excessive_permission_denials',
        userId,
        count: recentDenials.length,
        timeframe: '1 hour'
      })
    }
  }
}
```

### Monitorowanie wydajno≈õci
```typescript
class RBACPerformanceMonitor {
  async measurePermissionCheck(
    operation: () => Promise<boolean>
  ): Promise<{ result: boolean, duration: number }> {
    const start = performance.now()
    const result = await operation()    const duration = performance.now() - start
    
    // Rejestruj wolne sprawdzenia uprawnie≈Ñ
    if (duration > 100) { // pr√≥g 100ms
      console.warn(`Wolne sprawdzenie uprawnie≈Ñ: ${duration}ms`)
    }
    
    return { result, duration }
  }
}
```

---

## üîß Konfiguracja

### Plik konfiguracji r√≥l
```typescript
// shared\utils\permissions.constants.ts
export const ROLE_PERMISSIONS: Record<RoleSlug, Permissions> = {
  // Administrator ma wszystkie uprawnienia
  [USER_ROLES.ADMIN]: Object.values(PERMISSIONS) as Permissions,

  // itd...

```

---

## üìö Najlepsze praktyki

### Praktyki bezpiecze≈Ñstwa

#### 1. Zasada najmniejszych uprawnie≈Ñ
```typescript
// ‚úÖ Poprawnie: Przyznaj minimalne niezbƒôdne uprawnienia
const coachPermissions = [
  Permission.TRAINING_READ,
  Permission.TRAINING_UPDATE, // Tylko w≈Çasne treningi
  Permission.USER_READ // Tylko przypisani sportowcy
]

// ‚ùå B≈ÇƒÖd: Przyznawanie nadmiernych uprawnie≈Ñ
const coachPermissions = [
  Permission.USER_DELETE, // Trenerzy nie powinni usuwaƒá u≈ºytkownik√≥w
  Permission.SYSTEM_CONFIG // Trenerzy nie potrzebujƒÖ dostƒôpu do systemu
]
```

#### 2. Regularne audyty uprawnie≈Ñ
```typescript
// Automatyczny przeglƒÖd uprawnie≈Ñ
class PermissionReview {
  async reviewUserPermissions(userId: number) {
    const user = await getUserWithRole(userId)
    const lastReview = await getLastPermissionReview(userId)
    
    // PrzeglƒÖd co 90 dni
    if (daysSince(lastReview) > 90) {
      await this.flagForReview(userId, 'Wymagany regularny przeglƒÖd')
    }
    
    // Sprawd≈∫ nieu≈ºywane uprawnienia
    const unusedPermissions = await this.findUnusedPermissions(userId)
    if (unusedPermissions.length > 0) {
      await this.flagForReview(userId, 'Wykryto nieu≈ºywane uprawnienia')
    }
  }
}
```

#### 3. Bezpieczne ustawienia domy≈õlne
```typescript
// Domy≈õlnie najbardziej restrykcyjne uprawnienia
const defaultUserRole = UserRole.ATHLETE
const defaultPermissions = athletePermissions

// Wymagaj jawnego przyznawania uprawnie≈Ñ
function grantPermission(userId: number, permission: Permission) {
  // Wymagaj zatwierdzenia administratora dla wra≈ºliwych uprawnie≈Ñ
  if (SENSITIVE_PERMISSIONS.includes(permission)) {
    return this.requestPermissionApproval(userId, permission)
  }
  
  return this.grantPermissionImmediate(userId, permission)
}
```

---

## üîó PowiƒÖzana dokumentacja

::card-grid
#default
  ::card{icon="i-heroicons-shield-check" title="Przewodnik bezpiecze≈Ñstwa" to="/docs/development/security-guide"}
  Kompletne najlepsze praktyki bezpiecze≈Ñstwa i przewodnik implementacji.
  ::

  ::card{icon="i-heroicons-key" title="Uwierzytelnianie JWT" to="/docs/development/uwierzytelnianie-jwt"}
  Dokumentacja techniczna systemu uwierzytelniania.
  ::

  ::card{icon="i-heroicons-users" title="API zarzƒÖdzania u≈ºytkownikami" to="/docs/development/user-management-api"}
  Endpointy API z kontrolƒÖ dostƒôpu opartƒÖ na rolach.
  ::

  ::card{icon="i-heroicons-cog-6-tooth" title="Przewodnik administratora" to="/docs/admin/user-management-guide"}
  Procedury administracyjne dla zarzƒÖdzania u≈ºytkownikami i rolami.
  ::
::

---

## üìû Wsparcie

**Zesp√≥≈Ç programist√≥w**: dev@atp-system.com  
**Pytania o bezpiecze≈Ñstwo**: security@atp-system.com  
**Dokumentacja**: docs@atp-system.com

::alert{type="info"}
**Pytania o uprawnienia?** Skontaktuj siƒô z zespo≈Çem programist√≥w w sprawie modyfikacji r√≥l lub niestandardowych wymaga≈Ñ uprawnie≈Ñ.
::
